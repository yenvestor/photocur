/**
 * Professional filter effects
 */

/**
 * Apply motion blur effect
 */
export function applyMotionBlur(
  canvas: HTMLCanvasElement,
  options: { angle: number; distance: number }
): void {
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  const { angle, distance } = options;
  const radians = (angle * Math.PI) / 180;
  const dx = Math.cos(radians) * distance;
  const dy = Math.sin(radians) * distance;

  const originalData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const resultData = ctx.createImageData(canvas.width, canvas.height);

  for (let y = 0; y < canvas.height; y++) {
    for (let x = 0; x < canvas.width; x++) {
      let r = 0, g = 0, b = 0, a = 0, count = 0;

      const steps = Math.floor(distance);
      for (let step = -steps / 2; step <= steps / 2; step++) {
        const sampleX = Math.round(x + (dx * step) / steps);
        const sampleY = Math.round(y + (dy * step) / steps);

        if (sampleX >= 0 && sampleX < canvas.width && sampleY >= 0 && sampleY < canvas.height) {
          const idx = (sampleY * canvas.width + sampleX) * 4;
          r += originalData.data[idx];
          g += originalData.data[idx + 1];
          b += originalData.data[idx + 2];
          a += originalData.data[idx + 3];
          count++;
        }
      }

      const resultIdx = (y * canvas.width + x) * 4;
      if (count > 0) {
        resultData.data[resultIdx] = r / count;
        resultData.data[resultIdx + 1] = g / count;
        resultData.data[resultIdx + 2] = b / count;
        resultData.data[resultIdx + 3] = a / count;
      }
    }
  }

  ctx.putImageData(resultData, 0, 0);
}

/**
 * Apply emboss effect
 */
export function applyEmboss(canvas: HTMLCanvasElement): void {
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;

  const kernel = [
    -2, -1,  0,
    -1,  1,  1,
     0,  1,  2
  ];

  const result = new Uint8ClampedArray(data.length);

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      let r = 0, g = 0, b = 0;

      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const idx = ((y + ky) * width + (x + kx)) * 4;
          const kernelIdx = (ky + 1) * 3 + (kx + 1);
          const weight = kernel[kernelIdx];

          r += data[idx] * weight;
          g += data[idx + 1] * weight;
          b += data[idx + 2] * weight;
        }
      }

      const resultIdx = (y * width + x) * 4;
      result[resultIdx] = Math.max(0, Math.min(255, r + 128));
      result[resultIdx + 1] = Math.max(0, Math.min(255, g + 128));
      result[resultIdx + 2] = Math.max(0, Math.min(255, b + 128));
      result[resultIdx + 3] = data[resultIdx + 3];
    }
  }

  const resultImageData = new ImageData(result, width, height);
  ctx.putImageData(resultImageData, 0, 0);
}